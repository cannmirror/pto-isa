# 8. 编程模型契约

## 8.1 范围

本章定义 Auto 与 Manual 两种模式下的架构安全编程契约。
重点是正确性与可移植边界，而不是后端特定优化技巧。

## 8.2 Auto 与 Manual 契约分工

### 8.2.1 Auto 模式

- 工具链 SHOULD 自动推导合法放置、顺序与调度。
- 生成代码 MUST 保持虚拟 ISA 语义。
- 在等价源码与选项下，用户可见行为 MUST 保持确定性。

### 8.2.2 Manual 模式

- 程序员 MAY 显式控制放置与同步。
- 用户显式编写的依赖与顺序点 MUST 被保留。
- 非法手工配置 MUST 以可执行诊断失败。

## 8.3 可移植安全编程规则

面向跨后端可移植的程序 SHOULD：

- 保持在文档定义的指令族合法域内
- 避免依赖实现定义副作用
- 在数据流无法保证顺序时显式使用同步
- 将 dtype/layout/location 组合限制在后端交集画像内

## 8.4 性能导向且可移植的模式

可移植模式包括：

- 显式且域安全的 tiling 与有效区域管理
- 通过事件/`TSYNC` 建立清晰的生产-消费边界
- 使用能力检查进行后端受控特化
- 对不支持组合提供确定性回退路径

## 8.5 反模式

以下做法不具可移植性，SHOULD 避免：

- 将有效域外值当作有意义数据读取
- 依赖未文档化流水线时序行为
- 在无依赖定义时假设隐式顺序
- 未经画像门控直接编码后端特定假设

## 8.6 调试与验证流程

建议流程：

1. 结构正确性检查（类型、元数、属性）
2. 合法域检查（shape/layout/location 组合）
3. 同步检查（依赖完备性）
4. 后端一致性检查（画像约束）
5. 跨代表目标差分行为检查

## 8.7 兼容说明

当代码依赖实现定义行为时：

- 假设 MUST 被文档化
- 后端画像约束 MUST 明确声明
- 在可行时 SHOULD 提供回退行为
