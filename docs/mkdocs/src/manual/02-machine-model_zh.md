# 2. 执行模型

## 2.1 范围

本章定义虚拟 ISA 程序面向的抽象执行模型。
它描述架构可见的顺序与职责边界，不描述微架构内部实现。

## 2.2 执行代理

抽象 PTO 机器由三个概念代理构成：

- **Host machine**：准备负载、提交执行、管理全局资源。
- **Device machine**：在执行资源间调度 Tile 程序。
- **Core machine**：执行 Tile/标量指令和同步原语。

实现可以在内部采用不同映射，但 MUST 保持架构可见行为一致。

## 2.3 程序粒度

PTO 程序以 Tile 粒度运行：

- 程序是对 tile、scalar、memory、event 值进行操作的有序指令序列。
- 执行单元 MAY 并发处理相互独立的 Tile 程序。
- 可见顺序 MUST 遵循数据依赖与显式同步语义。

## 2.4 派发与调度

调度策略属于实现定义，但受架构规则约束：

- 独立工作 MAY 乱序并行执行。
- 有依赖的工作 MUST 满足要求的 happens-before 关系。
- 后端/运行时 MAY 采用 SPMD、MPMD 或混合派发模型。

## 2.5 架构可见顺序域

顺序语义在三个域上定义：

1. **程序顺序域**
- 在单一依赖链中，后续操作 MUST 观察到前序已提交效果。

2. **事件/同步域**
- 事件操作与 `TSYNC` MUST 建立架构定义的顺序点。

3. **内存可见性域**
- `TLOAD`/`TSTORE` 的可见性遵循第 11 章内存顺序约束。

## 2.6 Auto 与 Manual 职责

PTO 在架构层支持两种职责模型：

- **Auto 模式**
  - 编译器/运行时 SHOULD 自动插入合法同步与放置策略。
  - 用户意图保留为架构可见语义，执行细节由工具链管理。

- **Manual 模式**
  - 程序员负责显式放置、顺序控制与流水线安全调度。
  - 工具链 MUST 保留显式编写的同步语义。

## 2.7 实现定义边界

以下内容属于实现定义，且 MUST 在后端画像中说明：

- 调度启发策略
- 流水线占用与发射细节
- 内部缓冲与临时放置
- 后端支持子集的合法性约束

这些实现差异 MUST NOT 改变架构定义语义。
