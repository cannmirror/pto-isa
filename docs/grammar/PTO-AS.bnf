; PTO-AS (PTO Assembly) BNF
;
; This grammar describes the synchronous PTO-AS surface syntax used by the ISA docs.
; The format is MLIR-inspired (SSA values, MLIR-like types), but does not model async event flow.
;

<program>        ::= { <stmt> }

<stmt>           ::= <instr_stmt> | <directive_stmt>

<directive_stmt> ::= <arg_decl> | <const_decl>
<arg_decl>       ::= '.arg' <ssa> ':' <type> ';'?
<const_decl>     ::= '.const' <ssa> '=' <literal> ':' <type> ';'?

; An instruction is one line. It may optionally bind SSA results.
; Type signatures are recommended for readability but optional.
<instr_stmt>     ::= [ <ssa_list> '=' ] <opcode> <operand_list> [ <attr_dict> ] [ ':' <type_sig> ] ';'?

<ssa_list>       ::= <ssa> { ',' <ssa> }
<operand_list>   ::= <operand> { ',' <operand> }

; Operands may be SSA values, an indexed memory view (PTX-like), or an opaque attribute literal (e.g. `#pto.op<TADD>`).
<operand>        ::= <ssa> | <ssa> '[' <index> ',' <index> ']' | <opaque_attr>

<attr_dict>      ::= '{' [ <attr_list> ] '}'
<attr_list>      ::= <attr> { ',' <attr> }
<attr>           ::= <identifier> '=' <attr_value>
<attr_value>     ::= <identifier> | <literal> | <opaque_attr>
<opaque_attr>    ::= '#' <identifier> '<' { <attr_char> } '>'

<type_sig>       ::= <type> | '(' <type_list> ')' '->' <type> | '(' <type_list> ')' '->' '(' <type_list> ')'
<type_list>      ::= <type> { ',' <type> }

<type>           ::= <mlir_type>
<mlir_type>      ::= { <type_char> }

<opcode>         ::= <identifier>
<ssa>            ::= '%' <identifier>
<index>          ::= <ssa> | <literal>
<literal>        ::= <integer> | <float>
<identifier>     ::= <id_start> { <id_continue> }

<integer>        ::= ['-'] <digit> { <digit> }
<float>          ::= ['-'] <digit> { <digit> } '.' <digit> { <digit> }

<id_start>       ::= 'A'..'Z' | 'a'..'z' | '_'
<id_continue>    ::= <id_start> | <digit> | '.'
<digit>          ::= '0'..'9'

<type_char>      ::= ? any character except newline ?
<attr_char>      ::= ? any character except '>' and newline ?
