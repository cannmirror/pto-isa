# PTO 机器模型（抽象）

本文档定义了 **PTO ISA** 的抽象机器模型，该模型由 **PTO Tile 库** 提供。

其目标是提供一个在快速演进的设备代际间保持稳定的编程模型：

* 不同产品可能在指令集细节、片上存储布局和调度行为上存在差异。
* PTO 抽象了这些差异，使得代码可以移植，同时仍然允许专家用户在需要时管理内存布局、同步和调度。

## 编程风格：PTO-Auto 与 PTO-Manual

PTO 支持两种互补的使用风格：

* **PTO-Auto**：优先考虑生产效率和可移植性。
    * 编译器/运行时选择内存布局。
    * 编译器插入所需的同步。
    * 编译器调度操作（并在可用时应用融合，例如 VF 融合）。
* **PTO-Manual**：优先考虑控制和峰值性能。
    * 程序员控制内存布局和绑定（例如 `TASSIGN`）。
    * 程序员负责表达顺序/同步（例如事件、`TSYNC`）。
    * 程序员控制操作调度；编译器专注于局部变换和融合。

在实践中，许多应用会混合使用两种风格：从 PTO-Auto 开始，然后手动优化关键内核。

## 执行粒度：Tile 程序与 Tile 图

PTO 程序在 **Tile 粒度** 上编写：

* **Tile** 是片上存储的单位，也是大多数计算操作的单位。
* **Tile 程序** 是一系列针对 Tile、全局张量、标量和事件的 PTO 操作序列。
* **Tile 图** 是一组具有显式数据依赖关系的 Tile 程序（或块），通常由全局内存读写和事件顺序引发。

PTO 机器模型解释了这些程序如何在设备上执行。

## 机器层次结构

该模型使用三个概念层：

* **PTO Core Machine**：运行单个 Tile 指令序列的最小执行代理。
* **PTO Device Machine**：一组 PTO Core Machines 加上一个调度器，该调度器将 Tile 块映射到核心上，并强制执行全局内存依赖关系。
* **PTO Host Machine**：主机端的系统，用于准备工作（编译、缓存、图调度）并将其提交到设备。

根据平台的不同，可能还存在额外的概念组件：

* **集体通信单元**：设备间通信（多卡/多节点）。
* **DMA / 预取引擎**：在全局内存和片上缓存之间进行后台数据移动。

## PTO Core Machine

一个 **PTO Core Machine** 执行一个 Tile 指令流。该模型暴露了以下程序员可见的概念。

### 标量控制（标量单元）

核心包含一个 **标量单元**，用于驱动：

* 控制流（生成代码中的分支、循环）。
* 内存操作的地址计算。
* 事件操作和显式同步。

从编程模型的角度看，与 Tile 操作相比，标量操作是“快速控制”，用于协调 Tile 计算和移动。

### Tile 执行引擎

核心提供多个 Tile 执行引擎（流水线）。确切的名称因目标而异，但概念上包括：

* **向量流水线**：逐元素 Tile 操作（加法、乘法、比较等）。
* **矩阵/立方体流水线**：矩阵乘法/专用矩阵操作。
* **内存流水线**：全局内存移动和布局变换。
* **固定功能单元**：目标特定的加速器（可选）。

ISA 将每条指令分配给一个流水线类。事件可以表达流水线类之间的顺序，而无需完整核心屏障。

### Tile 存储和共享内存

每个核心都有片上存储，建模为：

* **Tile 存储**：类似寄存器文件的存储，用于 Tile 对象（例如 `Vec`、`Mat`、`Left`、`Right`、`Acc`）。
* **共享内存**（模型中可选）：用于数据交换和/或协作模式的核心本地暂存器。

`docs/isa/` 中的指令页定义了哪些 Tile 类型和布局对每条指令是合法的。

## PTO Device Machine

**PTO Device Machine** 并发地管理许多 Tile 块：

* 它将工作分解为 **Tile 块**（确切的单元由实现定义；通常是一个小的 Tile 程序或 Tile 图的一个区域）。
* 它将 Tile 块调度到可用的 PTO Core Machines 上。
* 它跟踪 **全局内存依赖关系**，以便通过 `TLOAD`/`TSTORE` 观察到的读写操作以合法的顺序发生。

### 顺序和依赖关系

抽象规则如下：

* **在单个核心的一个 Tile 块内**，对于具有显式数据或事件依赖关系的操作，程序顺序得以保留。
* **跨 Tile 块和核心**，只有在通过以下方式表达时，顺序才得到保证：
    * 全局内存依赖关系（例如，一个 `TSTORE` 产生数据，随后被 `TLOAD` 消耗），由运行时/驱动契约定义；和/或
    * 显式事件/同步，如 `docs/coding/Event_zh.md` 和 `docs/isa/TSYNC_zh.md` 所定义。

设备实现可以乱序且并行地执行独立的 Tile 块。

### MPMD 调度（任务 ID）

虽然许多内核以 SPMD 风格编写（所有核心运行相同的入口函数），但 PTO Device Machine 模型也允许多程序多数据 (MPMD) 风格，即不同核心执行不同的 Tile 程序。

在抽象模型中，这表现为调度器选择一个 Tile 块（程序）并将其映射到一个核心。实现可能通过以下方式暴露此功能：

* 多个内核入口点（每个程序一个），和/或
* 调度器提供的 **任务 ID**，传递到单个入口函数中，用于分派程序体

另请参阅：

* `docs/coding/ProgrammingModel_zh.md`

## PTO Host Machine

**PTO Host Machine** 负责准备并向设备提交工作。常见职责包括：

* 编译/JIT Tile 代码并缓存编译后的函数。
* 构建和优化 Tile 图（调度、分区、替换）。
* 分配和管理全局内存缓冲区。
* 向一个或多个 PTO Device Machines 提交工作并协调完成。

从 ISA 的角度看，主机行为超出了范围；此处描述仅是为了澄清在端到端系统中，编译和调度决策可能位于何处。
